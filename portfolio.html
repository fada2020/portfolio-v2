<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartWork - Portfolio Project</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #fff;
            padding: 40px 60px;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            border-bottom: 4px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            color: #34495e;
            font-size: 2em;
            margin-top: 40px;
            margin-bottom: 20px;
            border-left: 6px solid #3498db;
            padding-left: 15px;
        }

        h3 {
            color: #555;
            font-size: 1.5em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 {
            color: #666;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-bottom: 30px;
            font-style: italic;
        }

        .badges {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .badge {
            display: inline-block;
            padding: 5px 12px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .badge.java { background: #f89820; }
        .badge.spring { background: #6db33f; }
        .badge.gradle { background: #02303a; }
        .badge.oracle { background: #f80000; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }

        th {
            background: #3498db;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #e74c3c;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        pre code {
            background: none;
            color: #ecf0f1;
            padding: 0;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .toc {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 30px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .toc h2 {
            margin-top: 0;
            font-size: 1.5em;
        }

        .toc ol {
            counter-reset: item;
            list-style: none;
            margin-left: 0;
        }

        .toc li {
            counter-increment: item;
            margin-bottom: 10px;
        }

        .toc li:before {
            content: counter(item) ". ";
            font-weight: bold;
            color: #3498db;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .feature-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-top: 4px solid #3498db;
        }

        .feature-card h3 {
            margin-top: 0;
            color: #3498db;
        }

        .checkmark {
            color: #28a745;
            font-weight: bold;
            margin-right: 5px;
        }

        .page-break {
            page-break-after: always;
        }

        hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 40px 0;
        }

        @media print {
            body {
                padding: 20px;
            }

            h2 {
                page-break-after: avoid;
            }

            pre {
                page-break-inside: avoid;
            }

            table {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <h1>SmartWork - Enterprise Intranet System</h1>
    <p class="subtitle">사내 업무관리 시스템 | Spring Boot 3.2 & Java 21 포트폴리오 프로젝트</p>

    <div class="badges">
        <span class="badge java">Java 21</span>
        <span class="badge spring">Spring Boot 3.2.1</span>
        <span class="badge gradle">Gradle 8.5</span>
        <span class="badge oracle">Oracle 19c</span>
    </div>

    <hr>

    <div class="toc">
        <h2>📋 목차</h2>
        <ol>
            <li>프로젝트 개요</li>
            <li>기술 스택</li>
            <li>프로젝트 구조</li>
            <li>핵심 기능</li>
            <li>아키텍처 설계</li>
            <li>기술적 의사결정</li>
            <li>구현 상세</li>
            <li>빌드 및 실행</li>
            <li>API 문서</li>
            <li>성능 최적화</li>
            <li>보안 고려사항</li>
            <li>배포 및 인프라</li>
            <li>향후 계획</li>
        </ol>
    </div>

    <div class="page-break"></div>

    <h2>🎯 프로젝트 개요</h2>

    <h3>프로젝트 배경</h3>
    <p><strong>SmartWork</strong>는 실제 기업의 사내 업무 시스템을 모델로 한 엔터프라이즈급 웹 애플리케이션입니다. 국내 대기업 및 중견기업에서 사용하는 그룹웨어/ERP 시스템의 핵심 기능을 구현하여, <strong>실무 환경에서 요구되는 엔터프라이즈 Java 개발 역량</strong>을 증명하기 위해 개발되었습니다.</p>

    <h3>프로젝트 목적</h3>

    <div class="feature-grid">
        <div class="feature-card">
            <h3>엔터프라이즈 아키텍처</h3>
            <ul>
                <li>Spring Boot 3.2 기반 계층화 아키텍처</li>
                <li>AOP를 활용한 관심사 분리</li>
                <li>대규모 트랜잭션 처리</li>
            </ul>
        </div>

        <div class="feature-card">
            <h3>보안 중심 개발</h3>
            <ul>
                <li>JWT 기반 Stateless 인증/인가</li>
                <li>RBAC 구현</li>
                <li>Spring Security 다층 보안 체계</li>
            </ul>
        </div>

        <div class="feature-card">
            <h3>데이터베이스 설계</h3>
            <ul>
                <li>Oracle 19c 연동 및 시퀀스 관리</li>
                <li>JPA/Hibernate ORM</li>
                <li>JPA Auditing 감사 추적</li>
            </ul>
        </div>

        <div class="feature-card">
            <h3>최신 기술 스택</h3>
            <ul>
                <li>Java 21 최신 기능</li>
                <li>Gradle 8.5 빌드 자동화</li>
                <li>SpringDoc OpenAPI 3.0</li>
            </ul>
        </div>
    </div>

    <h3>주요 성과</h3>
    <div class="success-box">
        <p><span class="checkmark">✅</span> <strong>16개 클래스</strong> - 도메인, 보안, AOP, 예외 처리 구현</p>
        <p><span class="checkmark">✅</span> <strong>Production-Ready</strong> - 실제 운영 환경에 적용 가능한 수준의 코드 품질</p>
        <p><span class="checkmark">✅</span> <strong>확장 가능한 구조</strong> - 추가 기능 개발을 위한 유연한 아키텍처</p>
        <p><span class="checkmark">✅</span> <strong>엔터프라이즈 패턴</strong> - 대규모 시스템에서 검증된 설계 패턴 적용</p>
    </div>

    <div class="page-break"></div>

    <h2>🛠 기술 스택</h2>

    <h3>Backend Framework</h3>
    <table>
        <thead>
            <tr>
                <th>기술</th>
                <th>버전</th>
                <th>용도</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Java</strong></td>
                <td>21</td>
                <td>최신 언어 기능 (Preview Features, Records, Pattern Matching)</td>
            </tr>
            <tr>
                <td><strong>Spring Boot</strong></td>
                <td>3.2.1</td>
                <td>엔터프라이즈 애플리케이션 프레임워크</td>
            </tr>
            <tr>
                <td><strong>Spring Security</strong></td>
                <td>6.2.0</td>
                <td>인증/인가 및 보안</td>
            </tr>
            <tr>
                <td><strong>Spring Data JPA</strong></td>
                <td>3.2.0</td>
                <td>ORM 및 데이터 액세스</td>
            </tr>
            <tr>
                <td><strong>Spring AOP</strong></td>
                <td>6.1.2</td>
                <td>관심사 분리 (로깅, 트랜잭션)</td>
            </tr>
        </tbody>
    </table>

    <h3>Security & Authentication</h3>
    <table>
        <thead>
            <tr>
                <th>기술</th>
                <th>버전</th>
                <th>용도</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>JJWT</strong></td>
                <td>0.12.3</td>
                <td>JWT 토큰 생성/검증</td>
            </tr>
            <tr>
                <td><strong>BCrypt</strong></td>
                <td>-</td>
                <td>비밀번호 암호화</td>
            </tr>
        </tbody>
    </table>

    <h3>Database</h3>
    <table>
        <thead>
            <tr>
                <th>기술</th>
                <th>버전</th>
                <th>용도</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Oracle Database</strong></td>
                <td>19c</td>
                <td>관계형 데이터베이스</td>
            </tr>
            <tr>
                <td><strong>HikariCP</strong></td>
                <td>5.1.0</td>
                <td>커넥션 풀 관리</td>
            </tr>
            <tr>
                <td><strong>Hibernate</strong></td>
                <td>6.4.0</td>
                <td>JPA 구현체</td>
            </tr>
        </tbody>
    </table>

    <h3>Build & Documentation</h3>
    <table>
        <thead>
            <tr>
                <th>기술</th>
                <th>버전</th>
                <th>용도</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Gradle</strong></td>
                <td>8.5</td>
                <td>빌드 자동화</td>
            </tr>
            <tr>
                <td><strong>SpringDoc OpenAPI</strong></td>
                <td>2.3.0</td>
                <td>REST API 문서 자동화</td>
            </tr>
            <tr>
                <td><strong>Lombok</strong></td>
                <td>1.18.30</td>
                <td>보일러플레이트 코드 제거</td>
            </tr>
            <tr>
                <td><strong>MapStruct</strong></td>
                <td>1.5.5</td>
                <td>DTO 매핑</td>
            </tr>
        </tbody>
    </table>

    <div class="page-break"></div>

    <h2>📁 프로젝트 구조</h2>

    <pre><code>smartwork/
├── src/
│   └── main/
│       ├── java/com/smartwork/
│       │   ├── domain/              # 도메인 엔티티
│       │   │   ├── BaseEntity.java
│       │   │   ├── User.java
│       │   │   ├── Role.java
│       │   │   ├── Permission.java
│       │   │   └── UserStatus.java
│       │   │
│       │   ├── repository/          # 데이터 액세스 계층
│       │   │   ├── UserRepository.java
│       │   │   ├── RoleRepository.java
│       │   │   └── PermissionRepository.java
│       │   │
│       │   ├── security/            # 보안 설정
│       │   │   ├── jwt/
│       │   │   │   └── JwtTokenProvider.java
│       │   │   ├── filter/
│       │   │   │   └── JwtAuthenticationFilter.java
│       │   │   └── service/
│       │   │       └── UserDetailsServiceImpl.java
│       │   │
│       │   ├── exception/           # 예외 처리
│       │   │   ├── BusinessException.java
│       │   │   ├── ErrorCode.java
│       │   │   ├── ErrorResponse.java
│       │   │   └── GlobalExceptionHandler.java
│       │   │
│       │   ├── dto/                 # 데이터 전송 객체
│       │   │   ├── ApiResponse.java
│       │   │   └── ErrorResponse.java
│       │   │
│       │   ├── aop/                 # AOP 관점
│       │   │   ├── LoggingAspect.java
│       │   │   └── TransactionAspect.java
│       │   │
│       │   └── SmartWorkApplication.java
│       │
│       └── resources/
│           ├── application.yml      # 설정 파일
│           └── application-prod.yml
│
├── build.gradle                     # Gradle 빌드 설정
├── settings.gradle
├── gradlew
└── README.md
</code></pre>

    <h3>계층별 설명</h3>

    <table>
        <thead>
            <tr>
                <th>계층</th>
                <th>책임</th>
                <th>주요 기술</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Domain</strong></td>
                <td>비즈니스 로직과 규칙 정의</td>
                <td>JPA Entity, Enum</td>
            </tr>
            <tr>
                <td><strong>Repository</strong></td>
                <td>데이터베이스 접근 추상화</td>
                <td>Spring Data JPA</td>
            </tr>
            <tr>
                <td><strong>Security</strong></td>
                <td>인증/인가 처리</td>
                <td>Spring Security, JWT</td>
            </tr>
            <tr>
                <td><strong>Exception</strong></td>
                <td>전역 예외 처리</td>
                <td>@RestControllerAdvice</td>
            </tr>
            <tr>
                <td><strong>DTO</strong></td>
                <td>계층 간 데이터 전송</td>
                <td>Record, MapStruct</td>
            </tr>
            <tr>
                <td><strong>AOP</strong></td>
                <td>관심사 분리 (로깅, 트랜잭션)</td>
                <td>Spring AOP, AspectJ</td>
            </tr>
        </tbody>
    </table>

    <div class="page-break"></div>

    <h2>🔥 핵심 기능</h2>

    <h3>1. JWT 기반 인증/인가 시스템</h3>

    <div class="info-box">
        <p><strong>Stateless 인증 방식</strong>을 채택하여 서버의 세션 부담을 제거하고, 수평 확장이 가능한 구조를 구현했습니다.</p>
    </div>

    <h4>구현 특징</h4>
    <ul>
        <li><strong>Access Token (1시간)</strong>: API 요청 시 인증에 사용</li>
        <li><strong>Refresh Token (24시간)</strong>: Access Token 갱신에 사용</li>
        <li><strong>HMAC-SHA512 서명 알고리즘</strong>: 높은 보안성 제공</li>
        <li><strong>JJWT 0.12.3</strong>: 최신 JWT 라이브러리 사용</li>
    </ul>

    <h4>코드 예시 - JWT 토큰 생성</h4>
    <pre><code>@Component
public class JwtTokenProvider {
    private final SecretKey secretKey;
    private final long accessTokenValidityMs;

    public String generateAccessToken(Authentication authentication) {
        String username = authentication.getName();
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenValidityMs);

        return Jwts.builder()
                .subject(username)
                .claim("auth", authorities)
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(secretKey, Jwts.SIG.HS512)
                .compact();
    }
}</code></pre>

    <h3>2. RBAC (Role-Based Access Control)</h3>

    <div class="info-box">
        <p><strong>3계층 권한 모델</strong>로 세밀한 권한 관리를 구현했습니다: User → Role → Permission</p>
    </div>

    <h4>권한 구조</h4>
    <ul>
        <li><strong>User</strong>: 시스템 사용자 (여러 Role 보유 가능)</li>
        <li><strong>Role</strong>: 역할 (ADMIN, MANAGER, USER 등)</li>
        <li><strong>Permission</strong>: 세부 권한 (READ, WRITE, DELETE 등)</li>
    </ul>

    <h4>코드 예시 - RBAC 모델</h4>
    <pre><code>@Entity
@Table(name = "users")
public class User extends BaseEntity {
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();

    public boolean hasPermission(String permissionName) {
        return roles.stream()
                .flatMap(role -> role.getPermissions().stream())
                .anyMatch(permission ->
                    permission.getPermissionName().equals(permissionName));
    }
}</code></pre>

    <h3>3. AOP 기반 로깅 및 트랜잭션 모니터링</h3>

    <div class="info-box">
        <p><strong>관심사 분리(Separation of Concerns)</strong>를 통해 비즈니스 로직과 횡단 관심사를 분리했습니다.</p>
    </div>

    <h4>구현 범위</h4>
    <ul>
        <li><strong>Controller/Service/Repository</strong> 계층별 자동 로깅</li>
        <li><strong>성능 모니터링</strong>: StopWatch로 메서드 실행 시간 측정</li>
        <li><strong>느린 메서드 감지</strong>: 3초 이상 소요 시 경고 로그</li>
        <li><strong>트랜잭션 경계 추적</strong>: 격리 수준, 전파 옵션 로깅</li>
    </ul>

    <h4>코드 예시 - 로깅 Aspect</h4>
    <pre><code>@Aspect
@Component
public class LoggingAspect {

    @Around("execution(* com.smartwork.service.*.*(..))")
    public Object logServiceExecution(ProceedingJoinPoint joinPoint)
            throws Throwable {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        try {
            Object result = joinPoint.proceed();
            stopWatch.stop();

            log.info("[SERVICE] {}.{}() - SUCCESS in {}ms",
                className, methodName, stopWatch.getTotalTimeMillis());

            if (stopWatch.getTotalTimeMillis() > 3000) {
                log.warn("SLOW METHOD: {}.{}() took {}ms",
                    className, methodName, stopWatch.getTotalTimeMillis());
            }

            return result;
        } catch (Exception e) {
            stopWatch.stop();
            log.error("[SERVICE] {}.{}() - FAILED: {}",
                className, methodName, e.getMessage());
            throw e;
        }
    }
}</code></pre>

    <div class="page-break"></div>

    <h3>4. JPA Auditing을 통한 감사 추적</h3>

    <div class="info-box">
        <p>모든 엔티티의 <strong>생성/수정 이력을 자동으로 추적</strong>하여 데이터 변경 이력을 관리합니다.</p>
    </div>

    <h4>추적 정보</h4>
    <ul>
        <li><code>createdAt</code>: 생성 시각</li>
        <li><code>createdBy</code>: 생성자</li>
        <li><code>updatedAt</code>: 최종 수정 시각</li>
        <li><code>updatedBy</code>: 최종 수정자</li>
        <li><code>isDeleted</code>: Soft Delete 플래그</li>
    </ul>

    <h4>코드 예시 - Base Entity</h4>
    <pre><code>@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @CreatedBy
    @Column(name = "created_by", length = 50, updatable = false)
    private String createdBy;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @LastModifiedBy
    @Column(name = "updated_by", length = 50)
    private String updatedBy;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    public void softDelete() {
        this.isDeleted = true;
        this.updatedAt = LocalDateTime.now();
    }
}</code></pre>

    <h3>5. 전역 예외 처리</h3>

    <div class="info-box">
        <p><strong>@RestControllerAdvice</strong>를 사용하여 모든 예외를 중앙에서 처리하고 일관된 에러 응답을 제공합니다.</p>
    </div>

    <h4>예외 처리 체계</h4>
    <ul>
        <li><strong>7개 카테고리, 30+ 에러 코드</strong> 정의</li>
        <li><strong>HTTP 상태 코드와 에러 코드 매핑</strong></li>
        <li><strong>다국어 에러 메시지 지원</strong> 가능 구조</li>
        <li><strong>Validation 에러 상세 정보</strong> 포함</li>
    </ul>

    <h4>코드 예시 - 에러 코드 Enum</h4>
    <pre><code>@Getter
@RequiredArgsConstructor
public enum ErrorCode {
    // Authentication & Authorization (2xxx)
    UNAUTHORIZED(HttpStatus.UNAUTHORIZED, "A001", "Authentication required"),
    INVALID_TOKEN(HttpStatus.UNAUTHORIZED, "A002", "Invalid token"),
    TOKEN_EXPIRED(HttpStatus.UNAUTHORIZED, "A003", "Token has expired"),
    ACCESS_DENIED(HttpStatus.FORBIDDEN, "A004", "Access denied"),
    ACCOUNT_LOCKED(HttpStatus.FORBIDDEN, "A006", "Account is locked"),

    // User Management (3xxx)
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, "U001", "User not found"),
    DUPLICATE_USERNAME(HttpStatus.CONFLICT, "U002", "Username already exists"),

    // Validation (4xxx)
    INVALID_INPUT_VALUE(HttpStatus.BAD_REQUEST, "V001", "Invalid input value"),

    // Database (5xxx)
    DATABASE_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "D001", "Database error"),

    // File (6xxx)
    FILE_UPLOAD_FAILED(HttpStatus.INTERNAL_SERVER_ERROR, "F001", "File upload failed"),

    // System (9xxx)
    INTERNAL_SERVER_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "S001", "Internal server error");

    private final HttpStatus status;
    private final String code;
    private final String message;
}</code></pre>

    <div class="page-break"></div>

    <h2>🏗 아키텍처 설계</h2>

    <h3>계층화 아키텍처 (Layered Architecture)</h3>

    <div class="info-box">
        <p>각 계층이 <strong>단일 책임(Single Responsibility)</strong>을 가지며, 명확한 의존성 방향을 유지합니다.</p>
    </div>

    <pre><code>┌─────────────────────────────────────┐
│        Presentation Layer           │  ← Controller, DTO
│         (REST API)                  │
└───────────────┬─────────────────────┘
                ↓
┌─────────────────────────────────────┐
│         Business Layer              │  ← Service, Business Logic
│     (Transaction Boundary)          │
└───────────────┬─────────────────────┘
                ↓
┌─────────────────────────────────────┐
│       Persistence Layer             │  ← Repository, JPA
│      (Data Access)                  │
└───────────────┬─────────────────────┘
                ↓
┌─────────────────────────────────────┐
│         Database Layer              │  ← Oracle 19c
│          (RDBMS)                    │
└─────────────────────────────────────┘

     Cross-Cutting Concerns (AOP)
     ├── Logging
     ├── Transaction Management
     ├── Security
     └── Exception Handling
</code></pre>

    <h3>설계 원칙</h3>

    <h4>SOLID 원칙 적용</h4>
    <table>
        <thead>
            <tr>
                <th>원칙</th>
                <th>적용 사례</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>S</strong> - Single Responsibility</td>
                <td>각 클래스는 하나의 책임만 담당 (User, Role, Permission 분리)</td>
            </tr>
            <tr>
                <td><strong>O</strong> - Open/Closed</td>
                <td>BaseEntity를 상속받아 확장 가능한 구조</td>
            </tr>
            <tr>
                <td><strong>L</strong> - Liskov Substitution</td>
                <td>인터페이스 기반 Repository 설계</td>
            </tr>
            <tr>
                <td><strong>I</strong> - Interface Segregation</td>
                <td>필요한 인터페이스만 의존</td>
            </tr>
            <tr>
                <td><strong>D</strong> - Dependency Inversion</td>
                <td>구현체가 아닌 추상화(Repository)에 의존</td>
            </tr>
        </tbody>
    </table>

    <h4>DRY (Don't Repeat Yourself)</h4>
    <ul>
        <li><code>BaseEntity</code>: 공통 필드 (생성일시, 수정일시 등) 추상화</li>
        <li><code>ApiResponse&lt;T&gt;</code>: 일관된 응답 포맷 제공</li>
        <li><code>ErrorResponse</code>: 에러 응답 표준화</li>
        <li>AOP: 로깅/트랜잭션 로직 중앙 관리</li>
    </ul>

    <h4>Separation of Concerns (관심사 분리)</h4>
    <ul>
        <li><strong>Domain</strong>: 비즈니스 규칙만 집중</li>
        <li><strong>Security</strong>: 인증/인가 전담</li>
        <li><strong>AOP</strong>: 횡단 관심사 처리</li>
        <li><strong>Exception</strong>: 에러 처리 전담</li>
    </ul>

    <div class="page-break"></div>

    <h2>💡 기술적 의사결정</h2>

    <h3>왜 Java 21을 선택했는가?</h3>

    <table>
        <thead>
            <tr>
                <th>기능</th>
                <th>이점</th>
                <th>활용</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Virtual Threads (Preview)</strong></td>
                <td>높은 동시성 처리</td>
                <td>대량 사용자 요청 처리 대비</td>
            </tr>
            <tr>
                <td><strong>Pattern Matching</strong></td>
                <td>간결한 코드</td>
                <td>타입 검사 및 캐스팅 간소화</td>
            </tr>
            <tr>
                <td><strong>Record</strong></td>
                <td>불변 DTO 자동 생성</td>
                <td>DTO 클래스 보일러플레이트 제거</td>
            </tr>
            <tr>
                <td><strong>LTS 지원 (2031년까지)</strong></td>
                <td>장기 지원</td>
                <td>안정적인 운영 환경 보장</td>
            </tr>
        </tbody>
    </table>

    <h3>왜 JWT를 선택했는가?</h3>

    <table>
        <thead>
            <tr>
                <th>비교 항목</th>
                <th>Session</th>
                <th>JWT</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>상태 관리</strong></td>
                <td>서버에 세션 저장 (Stateful)</td>
                <td>토큰에 정보 포함 (Stateless)</td>
            </tr>
            <tr>
                <td><strong>확장성</strong></td>
                <td>세션 공유 필요 (Redis 등)</td>
                <td>별도 저장소 불필요</td>
            </tr>
            <tr>
                <td><strong>서버 부하</strong></td>
                <td>세션 메모리 사용</td>
                <td>메모리 사용 최소</td>
            </tr>
            <tr>
                <td><strong>모바일 지원</strong></td>
                <td>Cookie 의존성</td>
                <td>HTTP Header 사용</td>
            </tr>
            <tr>
                <td><strong>보안</strong></td>
                <td>서버 측 관리</td>
                <td>서명 검증 필요</td>
            </tr>
        </tbody>
    </table>

    <div class="success-box">
        <p><strong>결론</strong>: 마이크로서비스 아키텍처 확장 가능성과 모바일 앱 지원을 고려하여 <strong>JWT 방식을 선택</strong>했습니다.</p>
    </div>

    <h3>왜 Oracle 19c를 선택했는가?</h3>

    <table>
        <thead>
            <tr>
                <th>비교 항목</th>
                <th>MySQL/PostgreSQL</th>
                <th>Oracle 19c</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>엔터프라이즈 기능</strong></td>
                <td>기본 기능</td>
                <td>고급 분석, 파티셔닝, RAC</td>
            </tr>
            <tr>
                <td><strong>ACID 보장</strong></td>
                <td>기본 지원</td>
                <td>강력한 ACID + 다양한 격리 수준</td>
            </tr>
            <tr>
                <td><strong>대용량 처리</strong></td>
                <td>제한적</td>
                <td>TB급 데이터 최적화</td>
            </tr>
            <tr>
                <td><strong>실무 활용도</strong></td>
                <td>스타트업, 중소기업</td>
                <td>대기업, 금융권, 공공기관</td>
            </tr>
            <tr>
                <td><strong>학습 가치</strong></td>
                <td>기본 SQL</td>
                <td>PL/SQL, 시퀀스, 고급 기능</td>
            </tr>
        </tbody>
    </table>

    <div class="success-box">
        <p><strong>결론</strong>: 실제 대기업/금융권 환경에서 가장 많이 사용되는 DBMS 경험을 쌓기 위해 <strong>Oracle 19c를 선택</strong>했습니다.</p>
    </div>

    <h3>왜 AOP를 적용했는가?</h3>

    <div class="info-box">
        <p>비즈니스 로직에 <strong>로깅/트랜잭션 코드가 반복되는 문제</strong>를 해결하기 위해 AOP를 도입했습니다.</p>
    </div>

    <h4>AOP 적용 전 vs 후</h4>
    <table>
        <thead>
            <tr>
                <th>구분</th>
                <th>AOP 적용 전</th>
                <th>AOP 적용 후</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>코드 중복</strong></td>
                <td>모든 메서드에 로깅 코드</td>
                <td>Aspect에 한 번만 작성</td>
            </tr>
            <tr>
                <td><strong>유지보수</strong></td>
                <td>변경 시 모든 클래스 수정</td>
                <td>Aspect만 수정</td>
            </tr>
            <tr>
                <td><strong>가독성</strong></td>
                <td>비즈니스 로직이 섞임</td>
                <td>비즈니스 로직만 집중</td>
            </tr>
            <tr>
                <td><strong>성능 모니터링</strong></td>
                <td>수동 추가 필요</td>
                <td>자동 적용</td>
            </tr>
        </tbody>
    </table>

    <div class="page-break"></div>

    <h2>📊 구현 상세</h2>

    <h3>JWT 인증 흐름</h3>

    <pre><code>1. 로그인 요청
   POST /api/auth/login
   Body: { username, password }

2. 인증 처리
   - UserDetailsService가 사용자 정보 조회
   - 비밀번호 검증 (BCrypt)
   - 계정 잠금 여부 확인

3. JWT 토큰 생성
   - Access Token (1시간) 생성
   - Refresh Token (24시간) 생성
   - HMAC-SHA512로 서명

4. 클라이언트에 토큰 전달
   Response: {
     accessToken: "eyJhbGc...",
     refreshToken: "eyJhbGc...",
     tokenType: "Bearer"
   }

5. 인증이 필요한 API 요청
   GET /api/users/profile
   Header: Authorization: Bearer {accessToken}

6. JWT 필터에서 토큰 검증
   - JwtAuthenticationFilter가 토큰 추출
   - JwtTokenProvider가 토큰 검증
   - SecurityContext에 인증 정보 설정

7. 컨트롤러에서 인증 정보 사용
   @PreAuthorize("hasPermission('USER_READ')")
   public UserResponse getProfile() {
       // 인증된 사용자 정보 사용
   }
</code></pre>

    <h3>트랜잭션 관리 전략</h3>

    <table>
        <thead>
            <tr>
                <th>격리 수준</th>
                <th>설명</th>
                <th>사용 시나리오</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>READ_UNCOMMITTED</strong></td>
                <td>커밋되지 않은 데이터 읽기 가능</td>
                <td>사용 안 함 (Dirty Read 위험)</td>
            </tr>
            <tr>
                <td><strong>READ_COMMITTED</strong></td>
                <td>커밋된 데이터만 읽기</td>
                <td>일반 조회 작업</td>
            </tr>
            <tr>
                <td><strong>REPEATABLE_READ</strong></td>
                <td>같은 데이터 반복 조회 보장</td>
                <td>중요 비즈니스 로직</td>
            </tr>
            <tr>
                <td><strong>SERIALIZABLE</strong></td>
                <td>완전한 격리</td>
                <td>금융 거래 등 (성능 저하 감수)</td>
            </tr>
        </tbody>
    </table>

    <div class="info-box">
        <p><strong>기본 전략</strong>: <code>READ_COMMITTED</code> 사용, 중요 트랜잭션은 <code>REPEATABLE_READ</code> 적용</p>
    </div>

    <div class="page-break"></div>

    <h2>🚀 빌드 및 실행</h2>

    <h3>사전 요구사항</h3>
    <ul>
        <li>Java 21 이상</li>
        <li>Oracle Database 19c</li>
        <li>Gradle 8.5 (또는 Gradle Wrapper 사용)</li>
    </ul>

    <h3>데이터베이스 설정</h3>
    <pre><code>-- Oracle SQL*Plus 또는 SQL Developer에서 실행

-- 1. 사용자 생성
CREATE USER smartwork IDENTIFIED BY smartwork123;

-- 2. 권한 부여
GRANT CONNECT, RESOURCE, DBA TO smartwork;
GRANT UNLIMITED TABLESPACE TO smartwork;

-- 3. 시퀀스 생성
CREATE SEQUENCE smartwork.USER_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE smartwork.ROLE_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE smartwork.PERMISSION_SEQ START WITH 1 INCREMENT BY 1;
</code></pre>

    <h3>애플리케이션 설정</h3>
    <pre><code># src/main/resources/application.yml

spring:
  datasource:
    url: jdbc:oracle:thin:@localhost:1521:ORCL
    username: smartwork
    password: smartwork123
    driver-class-name: oracle.jdbc.OracleDriver

jwt:
  secret: [Base64 인코딩된 시크릿 키]
  access-token-validity: 3600000   # 1시간
  refresh-token-validity: 86400000 # 24시간
</code></pre>

    <h3>빌드 및 실행</h3>
    <pre><code># 1. 프로젝트 클론
git clone https://github.com/yourusername/smartwork.git
cd smartwork

# 2. 빌드 (테스트 포함)
./gradlew clean build

# 3. 테스트 스킵하고 빌드
./gradlew clean build -x test

# 4. 실행
./gradlew bootRun

# 또는 JAR 파일로 실행
java -jar build/libs/smartwork-0.0.1-SNAPSHOT.jar

# 5. Swagger UI 접속
http://localhost:8080/swagger-ui.html
</code></pre>

    <div class="page-break"></div>

    <h2>📖 API 문서</h2>

    <h3>API 응답 포맷</h3>

    <h4>성공 응답</h4>
    <pre><code>{
  "success": true,
  "message": "Success",
  "data": {
    "id": 1,
    "username": "admin",
    "email": "admin@example.com"
  },
  "timestamp": "2025-01-15T10:30:00"
}</code></pre>

    <h4>에러 응답</h4>
    <pre><code>{
  "success": false,
  "code": "U001",
  "message": "User not found",
  "errors": [
    {
      "field": "userId",
      "value": "999",
      "reason": "User does not exist"
    }
  ],
  "timestamp": "2025-01-15T10:30:00"
}</code></pre>

    <h3>주요 API 엔드포인트</h3>

    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Method</th>
                <th>Endpoint</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="3"><strong>Auth</strong></td>
                <td>POST</td>
                <td>/api/auth/login</td>
                <td>로그인 (JWT 토큰 발급)</td>
            </tr>
            <tr>
                <td>POST</td>
                <td>/api/auth/refresh</td>
                <td>Access Token 갱신</td>
            </tr>
            <tr>
                <td>POST</td>
                <td>/api/auth/logout</td>
                <td>로그아웃</td>
            </tr>
            <tr>
                <td rowspan="4"><strong>User</strong></td>
                <td>GET</td>
                <td>/api/users/{id}</td>
                <td>사용자 조회</td>
            </tr>
            <tr>
                <td>GET</td>
                <td>/api/users</td>
                <td>사용자 목록 조회</td>
            </tr>
            <tr>
                <td>POST</td>
                <td>/api/users</td>
                <td>사용자 생성</td>
            </tr>
            <tr>
                <td>PUT</td>
                <td>/api/users/{id}</td>
                <td>사용자 수정</td>
            </tr>
        </tbody>
    </table>

    <div class="page-break"></div>

    <h2>⚡ 성능 최적화</h2>

    <h3>데이터베이스 최적화</h3>

    <h4>1. N+1 문제 해결</h4>
    <pre><code>// JPQL Fetch Join 사용
@Query("SELECT u FROM User u " +
       "LEFT JOIN FETCH u.roles r " +
       "LEFT JOIN FETCH r.permissions " +
       "WHERE u.username = :username AND u.isDeleted = false")
Optional&lt;User&gt; findByUsernameWithRoles(@Param("username") String username);
</code></pre>

    <h4>2. 배치 처리</h4>
    <pre><code># application.yml
spring:
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
</code></pre>

    <h4>3. 커넥션 풀 최적화</h4>
    <pre><code># HikariCP 설정
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
</code></pre>

    <h3>애플리케이션 최적화</h3>

    <table>
        <thead>
            <tr>
                <th>기법</th>
                <th>적용 방법</th>
                <th>효과</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Lazy Loading</strong></td>
                <td>@ManyToMany(fetch = FetchType.LAZY)</td>
                <td>불필요한 조인 제거</td>
            </tr>
            <tr>
                <td><strong>DTO Projection</strong></td>
                <td>필요한 필드만 조회</td>
                <td>네트워크 부하 감소</td>
            </tr>
            <tr>
                <td><strong>MapStruct</strong></td>
                <td>컴파일 타임 매핑</td>
                <td>런타임 리플렉션 제거</td>
            </tr>
            <tr>
                <td><strong>Caching</strong></td>
                <td>@Cacheable 사용 계획</td>
                <td>DB 조회 횟수 감소</td>
            </tr>
        </tbody>
    </table>

    <div class="page-break"></div>

    <h2>🔒 보안 고려사항</h2>

    <h3>인증/인가 보안</h3>
    <ul>
        <li><strong>BCrypt 암호화</strong>: 비밀번호를 BCrypt로 해싱 (Salt 자동 생성)</li>
        <li><strong>계정 잠금</strong>: 5회 로그인 실패 시 1시간 잠금</li>
        <li><strong>토큰 만료</strong>: Access Token 1시간, Refresh Token 24시간</li>
        <li><strong>HTTPS 권장</strong>: 프로덕션 환경에서 필수</li>
    </ul>

    <h3>SQL Injection 방지</h3>
    <ul>
        <li><strong>JPA/Hibernate</strong>: Prepared Statement 자동 사용</li>
        <li><strong>@Param 바인딩</strong>: JPQL 파라미터 바인딩</li>
        <li><strong>Validation</strong>: @Valid, @NotNull 등으로 입력 검증</li>
    </ul>

    <h3>XSS/CSRF 방어</h3>
    <ul>
        <li><strong>Spring Security</strong>: CSRF 토큰 자동 생성</li>
        <li><strong>Content-Type 검증</strong>: JSON만 허용</li>
        <li><strong>입력 필터링</strong>: XSS 방지 필터 적용 계획</li>
    </ul>

    <h3>접근 제어</h3>
    <pre><code>@PreAuthorize("hasPermission('USER_WRITE')")
public UserResponse createUser(@Valid UserCreateRequest request) {
    // Permission 기반 세밀한 접근 제어
}

@PreAuthorize("hasRole('ADMIN')")
public List&lt;UserResponse&gt; getAllUsers() {
    // Role 기반 접근 제어
}</code></pre>

    <div class="page-break"></div>

    <h2>🚀 배포 및 인프라</h2>

    <h3>배포 아키텍처</h3>

    <div class="info-box">
        <p><strong>AWS EC2 프리티어</strong>를 활용한 Docker 기반 단일 컨테이너 배포로 <strong>월 비용 $0</strong> 달성</p>
    </div>

    <pre><code>GitHub Repository
       ↓
 [GitHub Actions CI/CD]
       ↓
  Docker Build & Test
       ↓
  Docker Hub Push
       ↓
   AWS EC2 (t2.micro)
   - Docker Container
   - 1GB RAM + 1GB Swap
       ↓
  AWS RDS (db.t3.micro)
  - Oracle 19c / PostgreSQL
</code></pre>

    <h3>Docker 컨테이너화</h3>

    <h4>멀티스테이지 빌드</h4>
    <table>
        <thead>
            <tr>
                <th>Stage</th>
                <th>역할</th>
                <th>이미지 크기</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Builder Stage</strong></td>
                <td>Gradle 8.5로 애플리케이션 빌드</td>
                <td>~800MB</td>
            </tr>
            <tr>
                <td><strong>Runtime Stage</strong></td>
                <td>JRE 21 기반 최종 이미지 생성</td>
                <td>~300MB</td>
            </tr>
        </tbody>
    </table>

    <h4>프리티어 최적화</h4>
    <ul>
        <li><strong>메모리 제한</strong>: 컨테이너 768MB, JVM 힙 512MB</li>
        <li><strong>Swap 메모리</strong>: 1GB 추가로 OOM 방지</li>
        <li><strong>G1GC 사용</strong>: 저지연 가비지 컬렉션</li>
        <li><strong>헬스체크</strong>: 30초마다 자동 상태 확인</li>
    </ul>

    <h4>보안 강화</h4>
    <pre><code># Non-root 사용자로 실행
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser
USER appuser

# 헬스체크 내장
HEALTHCHECK --interval=30s --timeout=3s \
    CMD wget --spider http://localhost:8080/actuator/health
</code></pre>

    <h3>CI/CD 파이프라인</h3>

    <div class="info-box">
        <p><strong>GitHub Actions</strong>를 활용한 완전 자동화 배포 파이프라인</p>
    </div>

    <h4>배포 플로우 (약 3-5분)</h4>
    <table>
        <thead>
            <tr>
                <th>단계</th>
                <th>작업</th>
                <th>소요 시간</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>1. 빌드</strong></td>
                <td>Gradle 빌드 및 테스트</td>
                <td>~2분</td>
            </tr>
            <tr>
                <td><strong>2. 이미지화</strong></td>
                <td>Docker 이미지 빌드 및 푸시</td>
                <td>~1분</td>
            </tr>
            <tr>
                <td><strong>3. 배포</strong></td>
                <td>EC2 SSH 접속 및 컨테이너 교체</td>
                <td>~30초</td>
            </tr>
            <tr>
                <td><strong>4. 검증</strong></td>
                <td>헬스체크 및 로그 확인</td>
                <td>~10초</td>
            </tr>
        </tbody>
    </table>

    <div class="warning-box">
        <p><strong>다운타임</strong>: 약 10-30초 (컨테이너 교체 시간)</p>
        <p>Blue-Green 배포는 리소스 제약으로 미적용</p>
    </div>

    <h4>자동화된 작업</h4>
    <ul>
        <li><code>main</code> 브랜치에 push 시 자동 배포</li>
        <li>빌드 실패 시 배포 중단</li>
        <li>이전 컨테이너 자동 정리</li>
        <li>배포 상태 실시간 로그 확인</li>
    </ul>

    <h3>인프라 구성</h3>

    <h4>AWS EC2 (t2.micro - 프리티어)</h4>
    <table>
        <thead>
            <tr>
                <th>항목</th>
                <th>사양</th>
                <th>비용</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>CPU</strong></td>
                <td>1 vCPU</td>
                <td rowspan="4">$0/월<br>(프리티어)</td>
            </tr>
            <tr>
                <td><strong>RAM</strong></td>
                <td>1 GB</td>
            </tr>
            <tr>
                <td><strong>Storage</strong></td>
                <td>8 GB EBS</td>
            </tr>
            <tr>
                <td><strong>Network</strong></td>
                <td>월 15GB 무료</td>
            </tr>
        </tbody>
    </table>

    <h4>AWS RDS (db.t3.micro - 프리티어)</h4>
    <ul>
        <li><strong>엔진</strong>: Oracle 19c / PostgreSQL 15</li>
        <li><strong>스토리지</strong>: 20GB SSD</li>
        <li><strong>백업</strong>: 자동 백업 7일 보관</li>
        <li><strong>비용</strong>: $0/월 (프리티어 월 750시간)</li>
    </ul>

    <h4>Docker Hub</h4>
    <ul>
        <li><strong>Repository</strong>: Public (무료)</li>
        <li><strong>이미지 크기</strong>: ~300MB</li>
        <li><strong>Pull 제한</strong>: 익명 100회/6시간, 인증 200회/6시간</li>
    </ul>

    <h3>모니터링 및 관리</h3>

    <h4>헬스체크</h4>
    <pre><code># Spring Boot Actuator
GET http://[EC2_IP]:8080/actuator/health

# 정상 응답
{
  "status": "UP",
  "components": {
    "db": {"status": "UP"},
    "diskSpace": {"status": "UP"}
  }
}
</code></pre>

    <h4>리소스 모니터링</h4>
    <ul>
        <li><strong>메모리 사용량</strong>: <code>docker stats</code>로 실시간 확인</li>
        <li><strong>로그 확인</strong>: <code>./deploy.sh logs 100</code></li>
        <li><strong>상태 체크</strong>: <code>./deploy.sh status</code></li>
        <li><strong>자동 재시작</strong>: 컨테이너 실패 시 자동 재시작</li>
    </ul>

    <h4>배포 관리 스크립트</h4>
    <pre><code># 전체 배포
./deploy.sh deploy

# 재시작
./deploy.sh restart

# 로그 확인
./deploy.sh logs 100

# 상태 확인
./deploy.sh status

# 리소스 정리
./deploy.sh cleanup
</code></pre>

    <h3>보안 설정</h3>

    <table>
        <thead>
            <tr>
                <th>항목</th>
                <th>설정</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>SSH 접근</strong></td>
                <td>키 기반 인증만 허용 (.pem 파일)</td>
            </tr>
            <tr>
                <td><strong>방화벽</strong></td>
                <td>필요한 포트만 개방 (22, 80, 8080)</td>
            </tr>
            <tr>
                <td><strong>환경 변수</strong></td>
                <td>GitHub Secrets로 민감 정보 관리</td>
            </tr>
            <tr>
                <td><strong>데이터베이스</strong></td>
                <td>EC2 보안 그룹에서만 접근 허용</td>
            </tr>
            <tr>
                <td><strong>컨테이너</strong></td>
                <td>Non-root 사용자로 실행</td>
            </tr>
        </tbody>
    </table>

    <h3>성과 및 개선</h3>

    <div class="success-box">
        <p><span class="checkmark">✅</span> <strong>완전 자동화</strong>: Git push만으로 프로덕션 배포</p>
        <p><span class="checkmark">✅</span> <strong>비용 최적화</strong>: 프리티어 활용으로 월 $0 운영</p>
        <p><span class="checkmark">✅</span> <strong>빠른 배포</strong>: 3-5분 내 배포 완료</p>
        <p><span class="checkmark">✅</span> <strong>안정성</strong>: 자동 헬스체크 및 재시작</p>
        <p><span class="checkmark">✅</span> <strong>모니터링</strong>: 실시간 로그 및 리소스 추적</p>
    </div>

    <h4>개선 계획</h4>
    <ul>
        <li><strong>Blue-Green 배포</strong>: 무중단 배포 (리소스 확보 시)</li>
        <li><strong>CloudWatch 통합</strong>: 메트릭 수집 및 알람</li>
        <li><strong>로드 밸런서</strong>: ELB로 고가용성 확보</li>
        <li><strong>Auto Scaling</strong>: 트래픽 기반 자동 확장</li>
        <li><strong>HTTPS 적용</strong>: Let's Encrypt SSL 인증서</li>
    </ul>

    <div class="page-break"></div>

    <h2>🛤 향후 계획</h2>

    <h3>Phase 1: 핵심 비즈니스 기능 구현 (현재 완료)</h3>
    <div class="success-box">
        <p><span class="checkmark">✅</span> JWT 기반 인증/인가 시스템</p>
        <p><span class="checkmark">✅</span> RBAC 권한 관리</p>
        <p><span class="checkmark">✅</span> AOP 로깅 및 트랜잭션 모니터링</p>
        <p><span class="checkmark">✅</span> 전역 예외 처리</p>
        <p><span class="checkmark">✅</span> JPA Auditing 감사 추적</p>
        <p><span class="checkmark">✅</span> Docker 컨테이너화</p>
        <p><span class="checkmark">✅</span> GitHub Actions CI/CD 파이프라인</p>
        <p><span class="checkmark">✅</span> AWS EC2 프리티어 배포</p>
    </div>

    <h3>Phase 2: 추가 기능 개발 (진행 예정)</h3>
    <ul>
        <li>게시판 시스템 (Board, Post, Comment)</li>
        <li>전자결재 시스템 (Approval, Workflow)</li>
        <li>근태관리 시스템 (Attendance, Leave)</li>
        <li>파일 업로드/다운로드 (Oracle BLOB 활용)</li>
        <li>알림 시스템 (WebSocket)</li>
    </ul>

    <h3>Phase 3: 테스트 및 인프라 확장 (계획 중)</h3>
    <ul>
        <li>단위 테스트 (JUnit 5, Mockito) - 80% 이상 커버리지</li>
        <li>통합 테스트 (TestContainers)</li>
        <li>E2E 테스트 (RestAssured, Playwright)</li>
        <li>HTTPS 적용 (Let's Encrypt SSL 인증서)</li>
        <li>도메인 연결 (Route 53)</li>
        <li>로드 밸런서 (Application Load Balancer)</li>
        <li>Auto Scaling (트래픽 기반 자동 확장)</li>
    </ul>

    <h3>Phase 4: 성능 및 모니터링 (장기 계획)</h3>
    <ul>
        <li>Redis 캐싱 (세션, 조회 데이터)</li>
        <li>Elasticsearch 검색 엔진 (전문 검색)</li>
        <li>CloudWatch 메트릭 및 알람</li>
        <li>Prometheus + Grafana 모니터링</li>
        <li>ELK 스택 로그 분석</li>
        <li>성능 테스트 (JMeter, Gatling)</li>
        <li>Kubernetes/ECS 컨테이너 오케스트레이션</li>
    </ul>

    <hr>

    <h2>📞 연락처</h2>
    <div class="info-box">
        <p><strong>개발자</strong>: [이혁주]</p>
        <p><strong>이메일</strong>: [leehyeokju1@gmail.com]</p>
        <p><strong>GitHub</strong>: [https://fada2020.github.io]</p>
        <p><strong>LinkedIn</strong>: [https://www.linkedin.com/in/hyeokju-lee]</p>
    </div>

    <hr>

    <div style="text-align: center; color: #7f8c8d; margin-top: 60px;">
        <p><strong>SmartWork</strong> - Enterprise Intranet System</p>
        <p>© 2025 All Rights Reserved</p>
        <p style="font-size: 0.9em; margin-top: 10px;">
            Spring Boot 3.2.1 | Java 21 | Oracle 19c | JWT Authentication
        </p>
    </div>

</body>
</html>
